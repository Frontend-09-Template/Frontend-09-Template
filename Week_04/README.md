# 学习笔记-字符串分析算法

## 字符串分析算法
**从易到难分类**

1. **字典树**-精确的匹配字符串与模式，大量高重复字符串的存储与分析，海量数据处理
2. **KMP**-模式匹配算法，在长字符串里找模式，一个长度为m的字符串匹配长度为n的字符串，处理的时间复杂度为m*n。 
3. **Wildcard**-带通配符的字符串模式
4. **正则**-字符串通用模式匹配
5. **状态机**-通用的字符串分析
6. **LL LR** 字符串多层级结构分析

**区别**

1. 字典树是检查两个字符串是否完全匹配，KMP是检查一个字符串是否是另一个字符串的部分。
2. Wildcard在KMP的基础上又增加了通配符，有问号表示匹配任意字符、星号表示匹配任意数量的任意字符。使用场景：文件查找。可以在O(n)的时间复杂度内处理，或者在O(m+n)的规模去处理。贪心算法。
3. 正则需要用到回溯。是字符串模式匹配的终极版本。
4. 正则和有限状态机是等价的。状态机可以对字符串做额外的处理，区别就是正则写起来很方便。
5. LR是比LL更强大的语法分析，理论性更强。HTML的语法分析，用到了stack实际上就是LR算法的简化版LR(0)。

## 字典树 Trie
实现
1. 使用Object或者Map保存字典树
1. 使用Object.create(null)创建比较干净的对象。
1. 字典树方法: 
  1. insert(word)执行插入，通过中间值重写循环赋值。
  1. most()获取出现次数最多的字符串，主要用到了递归，和比较node[$]的值。
  1. 生成字符串 ```String.fromCharCode(Math.random() * 26 + "a".charCodeAt(0))```

## KMP
实现
1. 接收两个参数：源数据source、pattern串
1. 实现计算跳转表格
1. 实现匹配算法

## Wildcard
最后一个星号之前的星号应该尽量少匹配字符，可以通过RegExp.exec实现，最后一个星号尽量多匹配字符，可以从后往前进行确定字符匹配。